// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

RWTexture2D<float> FurthestVisibleDistances;
Texture2D<float> DepthMap;
RWTexture2D<float4> MainViewMask;

int2 RayOriginPixels;
float2 RayDirection;
float ViewAngle;
int NumRaysPerDegree;

int RayTextureSize;
int VisibilityMaskWidth;
int VisibilityMaskHeight;
float MinAlpha;

float RayOriginHeight;
float HighlightAngle;
float4x4 InvOrthoMatrix;
float3 CameraPosition;
float3 HighlightCenter;

int MaximumVisibleDistancePixels;

float2x2 rotate(float angle)
{
    return float2x2(
        cos(angle), -sin(angle),
        sin(angle), cos(angle));
}
[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    float fogOfWarValue = MainViewMask[id.xy].r;
    
    float2 toPixel = (int2) id.xy - RayOriginPixels;
    float distance = length(toPixel.xy);
    float2 uv = float2(id.xy) / int2(VisibilityMaskWidth, VisibilityMaskHeight);
    uv = uv * 2.0f - 1.0f;
    float4 worldPos = mul(InvOrthoMatrix, float4(uv, DepthMap[id.xy], 1.0f));
    worldPos /= worldPos.w;
    
    float HighlightValue = 0.0f;
    if (RayOriginHeight > DepthMap[id.xy] && dot(normalize(worldPos.xyz - CameraPosition), normalize(HighlightCenter - CameraPosition)) > HighlightAngle)
    {
        HighlightValue = 1.0f;
    }
    
    
    float halfViewAngle = radians(ViewAngle / 2.0f);
    uint numRays = ceil(ViewAngle * NumRaysPerDegree);
    float angleStep = radians(ViewAngle) / (float) (numRays - 1);
    
    float2 normalizedToPixel = normalize(toPixel.xy);
    
    if (acos(dot(normalizedToPixel, RayDirection)) > halfViewAngle)
    {
        fogOfWarValue = max(min(fogOfWarValue, 0.1f), fogOfWarValue - 0.001f);
        MainViewMask[id.xy] = float4(fogOfWarValue, 0.0f, HighlightValue, MainViewMask[id.xy].w);
#ifdef DEBUG_SHADER
        MainViewMask[id.xy] = float4(fogOfWarValue, DepthMap[id.xy], HighlightValue , MainViewMask[id.xy].w);
#endif
        return;
    }
    float2 normalizedRayDirection = mul(rotate(-halfViewAngle), RayDirection);
    normalizedRayDirection = normalize(normalizedRayDirection);

    float dotProduct = dot(normalizedToPixel, normalizedRayDirection);
    float angle = acos(dotProduct);
    
    uint rayId = uint(round(angle / angleStep));
    if (rayId > numRays - 1)
    {
        fogOfWarValue = max(min(fogOfWarValue, 0.1f), fogOfWarValue - 0.001f);
        MainViewMask[id.xy] = float4(fogOfWarValue, 0.0f, HighlightValue, MainViewMask[id.xy].w);
#ifdef DEBUG_SHADER
        MainViewMask[id.xy] = float4(fogOfWarValue, DepthMap[id.xy], HighlightValue , MainViewMask[id.xy].w);
#endif
        return;
    }
    uint2 rayTextureCoord = uint2(rayId % (uint) RayTextureSize, rayId / (uint) RayTextureSize);
    float furthestVisibleDistance = FurthestVisibleDistances[rayTextureCoord].r;
    
    if (distance > furthestVisibleDistance)
    {
        fogOfWarValue = max(min(fogOfWarValue, 0.1f), fogOfWarValue - 0.001f);
        MainViewMask[id.xy] = float4(fogOfWarValue, 0.0f, HighlightValue, MainViewMask[id.xy].w);
#ifdef DEBUG_SHADER
        MainViewMask[id.xy] = float4(fogOfWarValue, DepthMap[id.xy], HighlightValue , MainViewMask[id.xy].w);
#endif
        return;
    }
    float alpha = lerp(0.0f, 1.0f,
        (
            dot(normalizedToPixel, RayDirection) - cos(halfViewAngle)
        ) / ( // -------------------------------
                    1.0f - cos(halfViewAngle)
        ) / MaximumVisibleDistancePixels * (MaximumVisibleDistancePixels - distance)
    );
    if (fogOfWarValue < 1.0f)
    {
        fogOfWarValue += alpha / 32;
        if (fogOfWarValue > 1.0)
        {
            fogOfWarValue = 1.0;
        }
        
    }
    else
    {
        fogOfWarValue = max(min(fogOfWarValue, 0.1f), fogOfWarValue - 0.001f);
    }
    MainViewMask[id.xy] = float4(fogOfWarValue, alpha, HighlightValue, MainViewMask[id.xy].w);
}