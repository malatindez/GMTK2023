#pragma kernel VisibilityCone

RWTexture2D<float> FurthestVisibleDistances;
Texture2D<float> MapDepthTexture;
float2 MapDepthTextureSize;

int2 RayOriginPixels;
float Height;
float HeightDecrease;
float2 RayDirection;
float Step;
float ViewAngle;
float ViewDistance;
int NumRaysPerDegree;
int NumSteps;
int RayTextureSize;

float2x2 rotate(float angle)
{
    return float2x2(
        cos(angle), -sin(angle),
        sin(angle), cos(angle));
}

[numthreads(64, 1, 1)]
void VisibilityCone (uint3 id : SV_DispatchThreadID)
{
    float halfViewAngle = radians(ViewAngle / 2.0f);
    int numRays = ceil(ViewAngle * NumRaysPerDegree);
    float angleStep = radians(ViewAngle) / (float) (numRays - 1);

    // find the angle depending on ray index.
    float angle = -halfViewAngle + id.x * angleStep;
    float2 direction = mul(rotate(angle), RayDirection.xy);
   
    direction = normalize(direction);

    float t = 0.0;
    
    // Raymarch through the depth map
    for (int i = 0; i < NumSteps; i++)
    {
        float2 texPosPixels = RayOriginPixels + direction * t;
        if (texPosPixels.x < 0.0 || texPosPixels.x > MapDepthTextureSize.x || 
            texPosPixels.y < 0.0 || texPosPixels.y > MapDepthTextureSize.y)
        {
            break;
        }
        // Sample the depth map
        float depth = MapDepthTexture[int2(texPosPixels)].r;
        // If we hit something, break out of the loop
        if (Height < depth)
        {
            t += Step;
            break;
        }

        // Move further along the ray
        t += Step;
        Height -= HeightDecrease * 2;
    }
    
    // Write furthest visible distance to buffer
    int x = id.x % RayTextureSize;
    int y = id.x / RayTextureSize;
    int2 texCoord = int2(x,y);
    if (x > RayTextureSize || y > RayTextureSize)
    {
        FurthestVisibleDistances[texCoord] = 0.0f;
    }
    FurthestVisibleDistances[texCoord] = 0.05f + t;

}
